<html><head><title>stuffit5::Reader</title></head>
<body>
<i><a href="index.html">Table of Contents</a>
 <a href="hierarchy.html">Class Hierarchy</a>
 <a href="diagrams.html">Class Diagrams</a></i>
<p><b><font size=+2> class  stuffit5::Reader</font>: public <!1><a href="stuffit5.event.ReaderEventDispatcher.html">stuffit5::event::ReaderEventDispatcher</a> </b><blockquote>
StuffIt Engine reader
</blockquote>
<hr>
<h4>Inheritance:</h4>
<applet code="ClassDiagram.class" width=600 height=605>
<param name=classes value="Cstuffit5::event::ProgressSizeMoveDispatcher,Mstuffit5.event.ProgressSizeMoveDispatcher.html,Cstuffit5::event::ProgressSizeEndDispatcher,Mstuffit5.event.ProgressSizeEndDispatcher.html,Cstuffit5::event::ProgressSizeBeginDispatcher,Mstuffit5.event.ProgressSizeBeginDispatcher.html,Cstuffit5::event::ProgressScanStepDispatcher,Mstuffit5.event.ProgressScanStepDispatcher.html,Cstuffit5::event::ProgressScanEndDispatcher,Mstuffit5.event.ProgressScanEndDispatcher.html,Cstuffit5::event::ProgressScanBeginDispatcher,Mstuffit5.event.ProgressScanBeginDispatcher.html,Cstuffit5::event::ProgressFilesMoveDispatcher,Mstuffit5.event.ProgressFilesMoveDispatcher.html,Cstuffit5::event::ProgressFilesEndDispatcher,Mstuffit5.event.ProgressFilesEndDispatcher.html,Cstuffit5::event::ProgressFilesBeginDispatcher,Mstuffit5.event.ProgressFilesBeginDispatcher.html,Cstuffit5::event::FolderInfoDispatcher,Mstuffit5.event.FolderInfoDispatcher.html,Cstuffit5::event::FolderDecodeEndDispatcher,Mstuffit5.event.FolderDecodeEndDispatcher.html,Cstuffit5::event::FolderDecodeBeginDispatcher,Mstuffit5.event.FolderDecodeBeginDispatcher.html,Cstuffit5::event::FileNewNameDispatcher,Mstuffit5.event.FileNewNameDispatcher.html,Cstuffit5::event::FileInfoDispatcher,Mstuffit5.event.FileInfoDispatcher.html,Cstuffit5::event::FileDeleteDispatcher,Mstuffit5.event.FileDeleteDispatcher.html,Cstuffit5::event::FileDecodeEndDispatcher,Mstuffit5.event.FileDecodeEndDispatcher.html,Cstuffit5::event::FileDecodeBeginDispatcher,Mstuffit5.event.FileDecodeBeginDispatcher.html,Cstuffit5::event::FileChangedNameDispatcher,Mstuffit5.event.FileChangedNameDispatcher.html,Cstuffit5::event::ErrorDispatcher,Mstuffit5.event.ErrorDispatcher.html,Cstuffit5::event::ArchiveNextDispatcher,Mstuffit5.event.ArchiveNextDispatcher.html,Cstuffit5::event::ArchiveInfoDispatcher,Mstuffit5.event.ArchiveInfoDispatcher.html,Cstuffit5::event::ArchiveDecodeEndDispatcher,Mstuffit5.event.ArchiveDecodeEndDispatcher.html,Cstuffit5::event::ArchiveDecodeBeginDispatcher,Mstuffit5.event.ArchiveDecodeBeginDispatcher.html,Cstuffit5::event::ReaderEventDispatcher,Mstuffit5.event.ReaderEventDispatcher.html,Cstuffit5::Reader,Mstuffit5.Reader.html">
<param name=before value="M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M">
<param name=after value="Ml_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,ML_SP,MD_SP,Md_,M">
<param name=indent value="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2">
<param name=arrowdir value="down">
</applet>
<hr>

<DL>
<DL>
<DT><h5>Public Fields</h5><DD><dt><a href="#DOC.181.8"></a><!1><a href="un.property.html">un::property</a>  &lt;bool&gt;   <b>useMacDrive</b> </b>
 <dd><i>MacDrive volume support option</i>
<dt><a href="#DOC.181.9"></a><!1><a href="un.property.html">un::property</a>  &lt;bool&gt;   <b>hasTextType</b> </b>
 <dd><i><code>true</code> when the reader supports text types</i>
<dt><a href="#DOC.181.18"></a><!1><a href="un.opt_property.html">un::opt_property</a>  &lt;<!2><a href="#DOC.244">stuffit5::TextType::type</a> &gt;   <b>textType</b> </b>
 <dd><i>Text type generated by the reader</i>
<dt><a href="#DOC.181.10"></a><!1><a href="un.property.html">un::property</a>  &lt;bool&gt;   <b>hasTextConversion</b> </b>
 <dd><i><code>true</code> when reader supports text conversion</i>
<dt><a href="#DOC.181.19"></a><!1><a href="un.opt_property.html">un::opt_property</a>  &lt;<!2><a href="#DOC.236">stuffit5::TextConversion::type</a> &gt;   <b>textConversion</b> </b>
 <dd><i>Text conversion option</i>
<dt><a href="#DOC.181.20"></a><!1><a href="un.property.html">un::property</a>  &lt;<!2><a href="#DOC.174">stuffit5::MacBinaryOutput::type</a> &gt;   <b>macBinaryOutput</b> </b>
 <dd><i>MacBinary output option</i>
<dt><a href="#DOC.181.11"></a><!1><a href="un.property.html">un::property</a>  &lt;std::string&gt;   <b>destinationFolder</b> </b>
 <dd><i>The destination folder: a location where the reader creates output
files that it extracts from the archive</i>
<dt><a href="#DOC.181.12"></a><!1><a href="un.property.html">un::property</a>  &lt;size_t&gt;   <b>classifierSpan</b> </b>
 <dd><i>Classifier span</i>
<dt><a href="#DOC.181.13"></a><!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="algorithm.Password.html">algorithm::Password</a> &gt;   <b>encryptionPassword</b> </b>
 <dd><i>The password used for file decryption in formats that support encrypted archives
(PrivateFile and StuffIt5)</i>
<dt><a href="#DOC.181.14"></a><!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="algorithm.Key.html">algorithm::Key</a> &gt;   <b>encryptionKey</b> </b>
 <dd><i>The key used for file decryption in formats that support encrypted archives
(PrivateFile and StuffIt5)</i>
<dt><a href="#DOC.181.15"></a><!1><a href="un.property.html">un::property</a>  &lt;std::string&gt;   <b>newFileName</b> </b>
 <dd><i>The name of an unnamed file</i>
<dt><a href="#DOC.181.21"></a><!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="stuffit5.ArchiveInfo.html">stuffit5::ArchiveInfo</a> &gt;   <b>archiveInfo</b> </b>
 <dd><i>Archive information class</i>
<dt><a href="#DOC.181.22"></a><!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="stuffit5.FileInfo.html">stuffit5::FileInfo</a> &gt;   <b>fileInfo</b> </b>
 <dd><i>File information class</i>
<dt><a href="#DOC.181.23"></a><!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="stuffit5.FolderInfo.html">stuffit5::FolderInfo</a> &gt;   <b>folderInfo</b> </b>
 <dd><i>Folder information class</i>
<dt><a href="#DOC.181.24"></a><!1><a href="un.property.html">un::property</a>  &lt;void*&gt;   <b>userData</b> </b>
 <dd><i>An arbitrary data pointer is carried to link instances of this class to
external per-instance data</i>
</DL><DL>
<DT><h5>Public Methods</h5><DD><dt><a href="#DOC.181.16"></a>exported  <b>Reader</b>() </b>
 <dd><i>Default constructor</i>
<dt><a href="#DOC.181.17"></a>exported  virtual  <b>~Reader</b>() </b>
 <dd><i>Destructor</i>
<dt><a href="#DOC.181.1"></a>exported  virtual  void  <b>open</b>(const std::string& <!1><a href="stuffit5.Error.name.html">name</a> ) </b>
 <dd><i>Opens an archive in the reader</i>
<dt><a href="#DOC.181.2"></a>exported  virtual  void  <b>classify</b>() </b>
 <dd><i>Determines archive format (<i>classifies</i> the archive)</i>
<dt><a href="#DOC.181.3"></a>exported  virtual  void  <b>scan</b>() </b>
 <dd><i>Scans the archive</i>
<dt><a href="#DOC.181.4"></a>exported  virtual  void  <b>decode</b>() </b>
 <dd><i>Decodes the archive and recreates all files contained in it at the
destination location</i>
<dt><a href="#DOC.181.5"></a>exported  virtual  void  <b>close</b>() </b>
 <dd><i>Closes the currently open archive</i>
<dt><a href="#DOC.181.6"></a>exported  virtual  bool  <b>canClassify</b>(<!2><a href="#DOC.100">stuffit5::Format::type</a>  format) const  </b>
 <dd><i>Returns <code>true</code> when the reader is capable of classifying
the format described by the <code>format</code> parameter</i>
<dt><a href="#DOC.181.7"></a>exported  virtual  bool  <b>canDecode</b>(<!2><a href="#DOC.100">stuffit5::Format::type</a>  format) const  </b>
 <dd><i>Returns <code>true</code> when the reader is capable of decoding
the format described by the <code>format</code> parameter</i>
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt><a href="#DOC.181.25"></a>bool  <b>isOpen</b> </b>
 <dd><i>True if an archive is open</i>
<dt><a href="#DOC.181.26"></a>bool  <b>hasFormat</b> </b>
 <dd><i>True if archive format is known</i>
<dt><a href="#DOC.181.27"></a>bool  <b>scanned</b> </b>
 <dd><i>True if archive scan is complete</i>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ReaderEventDispatcher.html"> stuffit5::event::ReaderEventDispatcher:</a></b>

<DL>
</DL>
<p><b>Inherited from <a href="stuffit5.event.ArchiveDecodeBeginDispatcher.html"> stuffit5::event::ArchiveDecodeBeginDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addArchiveDecodeBeginListener</b>(<!1><a href="stuffit5.event.ArchiveDecodeBeginListener.html">stuffit5::event::ArchiveDecodeBeginListener</a> * l)
<dt>void  <b>removeArchiveDecodeBeginListener</b>(<!1><a href="stuffit5.event.ArchiveDecodeBeginListener.html">stuffit5::event::ArchiveDecodeBeginListener</a> * l)
<dt>bool  <b>fireArchiveDecodeBeginEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ArchiveDecodeBeginListener.html">stuffit5::event::ArchiveDecodeBeginListener</a> *&gt;   <b>archiveDecodeBeginListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ArchiveDecodeEndDispatcher.html"> stuffit5::event::ArchiveDecodeEndDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addArchiveDecodeEndListener</b>(<!1><a href="stuffit5.event.ArchiveDecodeEndListener.html">stuffit5::event::ArchiveDecodeEndListener</a> * l)
<dt>void  <b>removeArchiveDecodeEndListener</b>(<!1><a href="stuffit5.event.ArchiveDecodeEndListener.html">stuffit5::event::ArchiveDecodeEndListener</a> * l)
<dt>void  <b>fireArchiveDecodeEndEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ArchiveDecodeEndListener.html">stuffit5::event::ArchiveDecodeEndListener</a> *&gt;   <b>archiveDecodeEndListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ArchiveInfoDispatcher.html"> stuffit5::event::ArchiveInfoDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addArchiveInfoListener</b>(<!1><a href="stuffit5.event.ArchiveInfoListener.html">stuffit5::event::ArchiveInfoListener</a> * l)
<dt>void  <b>removeArchiveInfoListener</b>(<!1><a href="stuffit5.event.ArchiveInfoListener.html">stuffit5::event::ArchiveInfoListener</a> * l)
<dt>bool  <b>fireArchiveInfoEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ArchiveInfoListener.html">stuffit5::event::ArchiveInfoListener</a> *&gt;   <b>archiveInfoListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ArchiveNextDispatcher.html"> stuffit5::event::ArchiveNextDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addArchiveNextListener</b>(<!1><a href="stuffit5.event.ArchiveNextListener.html">stuffit5::event::ArchiveNextListener</a> * l)
<dt>void  <b>removeArchiveNextListener</b>(<!1><a href="stuffit5.event.ArchiveNextListener.html">stuffit5::event::ArchiveNextListener</a> * l)
<dt>bool  <b>fireArchiveNextEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ArchiveNextListener.html">stuffit5::event::ArchiveNextListener</a> *&gt;   <b>archiveNextListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ErrorDispatcher.html"> stuffit5::event::ErrorDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addErrorListener</b>(<!1><a href="stuffit5.event.ErrorListener.html">stuffit5::event::ErrorListener</a> * l)
<dt>void  <b>removeErrorListener</b>(<!1><a href="stuffit5.event.ErrorListener.html">stuffit5::event::ErrorListener</a> * l)
<dt>bool  <b>fireErrorEvent</b>(<!1><a href="stuffit5.Error.type.html">stuffit5::Error::type</a>  error)
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ErrorListener.html">stuffit5::event::ErrorListener</a> *&gt;   <b>errorListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FileChangedNameDispatcher.html"> stuffit5::event::FileChangedNameDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFileChangedNameListener</b>(<!1><a href="stuffit5.event.FileChangedNameListener.html">stuffit5::event::FileChangedNameListener</a> * l)
<dt>void  <b>removeFileChangedNameListener</b>(<!1><a href="stuffit5.event.FileChangedNameListener.html">stuffit5::event::FileChangedNameListener</a> * l)
<dt>void  <b>fireFileChangedNameEvent</b>(const char* <!1><a href="stuffit5.Error.name.html">name</a> )
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FileChangedNameListener.html">stuffit5::event::FileChangedNameListener</a> *&gt;   <b>fileChangedNameListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FileDecodeBeginDispatcher.html"> stuffit5::event::FileDecodeBeginDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFileDecodeBeginListener</b>(<!1><a href="stuffit5.event.FileDecodeBeginListener.html">stuffit5::event::FileDecodeBeginListener</a> * l)
<dt>void  <b>removeFileDecodeBeginListener</b>(<!1><a href="stuffit5.event.FileDecodeBeginListener.html">stuffit5::event::FileDecodeBeginListener</a> * l)
<dt>bool  <b>fireFileDecodeBeginEvent</b>(uint32_t position)
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FileDecodeBeginListener.html">stuffit5::event::FileDecodeBeginListener</a> *&gt;   <b>fileDecodeBeginListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FileDecodeEndDispatcher.html"> stuffit5::event::FileDecodeEndDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFileDecodeEndListener</b>(<!1><a href="stuffit5.event.FileDecodeEndListener.html">stuffit5::event::FileDecodeEndListener</a> * l)
<dt>void  <b>removeFileDecodeEndListener</b>(<!1><a href="stuffit5.event.FileDecodeEndListener.html">stuffit5::event::FileDecodeEndListener</a> * l)
<dt>void  <b>fireFileDecodeEndEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FileDecodeEndListener.html">stuffit5::event::FileDecodeEndListener</a> *&gt;   <b>fileDecodeEndListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FileDeleteDispatcher.html"> stuffit5::event::FileDeleteDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFileDeleteListener</b>(<!1><a href="stuffit5.event.FileDeleteListener.html">stuffit5::event::FileDeleteListener</a> * l)
<dt>void  <b>removeFileDeleteListener</b>(<!1><a href="stuffit5.event.FileDeleteListener.html">stuffit5::event::FileDeleteListener</a> * l)
<dt>bool  <b>fireFileDeleteEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FileDeleteListener.html">stuffit5::event::FileDeleteListener</a> *&gt;   <b>fileDeleteListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FileInfoDispatcher.html"> stuffit5::event::FileInfoDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFileInfoListener</b>(<!1><a href="stuffit5.event.FileInfoListener.html">stuffit5::event::FileInfoListener</a> * l)
<dt>void  <b>removeFileInfoListener</b>(<!1><a href="stuffit5.event.FileInfoListener.html">stuffit5::event::FileInfoListener</a> * l)
<dt>bool  <b>fireFileInfoEvent</b>(uint32_t position)
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FileInfoListener.html">stuffit5::event::FileInfoListener</a> *&gt;   <b>fileInfoListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FileNewNameDispatcher.html"> stuffit5::event::FileNewNameDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFileNewNameListener</b>(<!1><a href="stuffit5.event.FileNewNameListener.html">stuffit5::event::FileNewNameListener</a> * l)
<dt>void  <b>removeFileNewNameListener</b>(<!1><a href="stuffit5.event.FileNewNameListener.html">stuffit5::event::FileNewNameListener</a> * l)
<dt>void  <b>fireFileNewNameEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FileNewNameListener.html">stuffit5::event::FileNewNameListener</a> *&gt;   <b>fileNewNameListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FolderDecodeBeginDispatcher.html"> stuffit5::event::FolderDecodeBeginDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFolderDecodeBeginListener</b>(<!1><a href="stuffit5.event.FolderDecodeBeginListener.html">stuffit5::event::FolderDecodeBeginListener</a> * l)
<dt>void  <b>removeFolderDecodeBeginListener</b>(<!1><a href="stuffit5.event.FolderDecodeBeginListener.html">stuffit5::event::FolderDecodeBeginListener</a> * l)
<dt>bool  <b>fireFolderDecodeBeginEvent</b>(uint32_t position)
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FolderDecodeBeginListener.html">stuffit5::event::FolderDecodeBeginListener</a> *&gt;   <b>folderDecodeBeginListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FolderDecodeEndDispatcher.html"> stuffit5::event::FolderDecodeEndDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFolderDecodeEndListener</b>(<!1><a href="stuffit5.event.FolderDecodeEndListener.html">stuffit5::event::FolderDecodeEndListener</a> * l)
<dt>void  <b>removeFolderDecodeEndListener</b>(<!1><a href="stuffit5.event.FolderDecodeEndListener.html">stuffit5::event::FolderDecodeEndListener</a> * l)
<dt>void  <b>fireFolderDecodeEndEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FolderDecodeEndListener.html">stuffit5::event::FolderDecodeEndListener</a> *&gt;   <b>folderDecodeEndListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.FolderInfoDispatcher.html"> stuffit5::event::FolderInfoDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addFolderInfoListener</b>(<!1><a href="stuffit5.event.FolderInfoListener.html">stuffit5::event::FolderInfoListener</a> * l)
<dt>void  <b>removeFolderInfoListener</b>(<!1><a href="stuffit5.event.FolderInfoListener.html">stuffit5::event::FolderInfoListener</a> * l)
<dt>bool  <b>fireFolderInfoEvent</b>(uint32_t position)
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.FolderInfoListener.html">stuffit5::event::FolderInfoListener</a> *&gt;   <b>folderInfoListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressFilesBeginDispatcher.html"> stuffit5::event::ProgressFilesBeginDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressFilesBeginListener</b>(<!1><a href="stuffit5.event.ProgressFilesBeginListener.html">stuffit5::event::ProgressFilesBeginListener</a> * l)
<dt>void  <b>removeProgressFilesBeginListener</b>(<!1><a href="stuffit5.event.ProgressFilesBeginListener.html">stuffit5::event::ProgressFilesBeginListener</a> * l)
<dt>void  <b>fireProgressFilesBeginEvent</b>(uint32_t files)
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressFilesBeginListener.html">stuffit5::event::ProgressFilesBeginListener</a> *&gt;   <b>progressFilesBeginListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressFilesEndDispatcher.html"> stuffit5::event::ProgressFilesEndDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressFilesEndListener</b>(<!1><a href="stuffit5.event.ProgressFilesEndListener.html">stuffit5::event::ProgressFilesEndListener</a> * l)
<dt>void  <b>removeProgressFilesEndListener</b>(<!1><a href="stuffit5.event.ProgressFilesEndListener.html">stuffit5::event::ProgressFilesEndListener</a> * l)
<dt>void  <b>fireProgressFilesEndEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressFilesEndListener.html">stuffit5::event::ProgressFilesEndListener</a> *&gt;   <b>progressFilesEndListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressFilesMoveDispatcher.html"> stuffit5::event::ProgressFilesMoveDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressFilesMoveListener</b>(<!1><a href="stuffit5.event.ProgressFilesMoveListener.html">stuffit5::event::ProgressFilesMoveListener</a> * l)
<dt>void  <b>removeProgressFilesMoveListener</b>(<!1><a href="stuffit5.event.ProgressFilesMoveListener.html">stuffit5::event::ProgressFilesMoveListener</a> * l)
<dt>bool  <b>fireProgressFilesMoveEvent</b>(uint32_t files)
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressFilesMoveListener.html">stuffit5::event::ProgressFilesMoveListener</a> *&gt;   <b>progressFilesMoveListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressScanBeginDispatcher.html"> stuffit5::event::ProgressScanBeginDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressScanBeginListener</b>(<!1><a href="stuffit5.event.ProgressScanBeginListener.html">stuffit5::event::ProgressScanBeginListener</a> * l)
<dt>void  <b>removeProgressScanBeginListener</b>(<!1><a href="stuffit5.event.ProgressScanBeginListener.html">stuffit5::event::ProgressScanBeginListener</a> * l)
<dt>void  <b>fireProgressScanBeginEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressScanBeginListener.html">stuffit5::event::ProgressScanBeginListener</a> *&gt;   <b>progressScanBeginListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressScanEndDispatcher.html"> stuffit5::event::ProgressScanEndDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressScanEndListener</b>(<!1><a href="stuffit5.event.ProgressScanEndListener.html">stuffit5::event::ProgressScanEndListener</a> * l)
<dt>void  <b>removeProgressScanEndListener</b>(<!1><a href="stuffit5.event.ProgressScanEndListener.html">stuffit5::event::ProgressScanEndListener</a> * l)
<dt>void  <b>fireProgressScanEndEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressScanEndListener.html">stuffit5::event::ProgressScanEndListener</a> *&gt;   <b>progressScanEndListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressScanStepDispatcher.html"> stuffit5::event::ProgressScanStepDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressScanStepListener</b>(<!1><a href="stuffit5.event.ProgressScanStepListener.html">stuffit5::event::ProgressScanStepListener</a> * l)
<dt>void  <b>removeProgressScanStepListener</b>(<!1><a href="stuffit5.event.ProgressScanStepListener.html">stuffit5::event::ProgressScanStepListener</a> * l)
<dt>bool  <b>fireProgressScanStepEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressScanStepListener.html">stuffit5::event::ProgressScanStepListener</a> *&gt;   <b>progressScanStepListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressSizeBeginDispatcher.html"> stuffit5::event::ProgressSizeBeginDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressSizeBeginListener</b>(<!1><a href="stuffit5.event.ProgressSizeBeginListener.html">stuffit5::event::ProgressSizeBeginListener</a> * l)
<dt>void  <b>removeProgressSizeBeginListener</b>(<!1><a href="stuffit5.event.ProgressSizeBeginListener.html">stuffit5::event::ProgressSizeBeginListener</a> * l)
<dt>void  <b>fireProgressSizeBeginEvent</b>(size_t <!2><a href="#DOC.8">size</a> )
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressSizeBeginListener.html">stuffit5::event::ProgressSizeBeginListener</a> *&gt;   <b>progressSizeBeginListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressSizeEndDispatcher.html"> stuffit5::event::ProgressSizeEndDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressSizeEndListener</b>(<!1><a href="stuffit5.event.ProgressSizeEndListener.html">stuffit5::event::ProgressSizeEndListener</a> * l)
<dt>void  <b>removeProgressSizeEndListener</b>(<!1><a href="stuffit5.event.ProgressSizeEndListener.html">stuffit5::event::ProgressSizeEndListener</a> * l)
<dt>void  <b>fireProgressSizeEndEvent</b>()
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressSizeEndListener.html">stuffit5::event::ProgressSizeEndListener</a> *&gt;   <b>progressSizeEndListeners</b>
</DL></DL>
<p><b>Inherited from <a href="stuffit5.event.ProgressSizeMoveDispatcher.html"> stuffit5::event::ProgressSizeMoveDispatcher:</a></b>

<DL>
<DL>
<DT><h5>Public Methods</h5><DD><dt>void  <b>addProgressSizeMoveListener</b>(<!1><a href="stuffit5.event.ProgressSizeMoveListener.html">stuffit5::event::ProgressSizeMoveListener</a> * l)
<dt>void  <b>removeProgressSizeMoveListener</b>(<!1><a href="stuffit5.event.ProgressSizeMoveListener.html">stuffit5::event::ProgressSizeMoveListener</a> * l)
<dt>bool  <b>fireProgressSizeMoveEvent</b>(size_t <!2><a href="#DOC.8">size</a> )
</DL><DL>
<DT><h5>Protected Fields</h5><DD><dt>std::list &lt;<!1><a href="stuffit5.event.ProgressSizeMoveListener.html">stuffit5::event::ProgressSizeMoveListener</a> *&gt;   <b>progressSizeMoveListeners</b>
</DL></DL>
<hr>
<h4>Documentation</h4>
<blockquote>
StuffIt Engine reader.

<p>StuffIt Engine reader is a class used to read (classify, scan, decode) archives
and encoded files.



</blockquote>
<DL>

<A NAME="Reader">
<A NAME ="DOC.181.16">
<DT><TT><b> exported  Reader()</b></TT>
<DD>Default constructor
<dl></DL><P>
<A NAME="~Reader">
<A NAME ="DOC.181.17">
<DT><TT><b> exported  virtual  ~Reader()</b></TT>
<DD>Destructor
<dl></DL><P>
<A NAME="open">
<A NAME ="DOC.181.1">
<DT><TT><b> exported  virtual  void  open(const std::string& <!1><a href="stuffit5.Error.name.html">name</a> )</b></TT>
<DD>Opens an archive in the reader. <code>name</code> is an
absolute or relative path name of the archive file.


<dl><dt><b>Throws:</b><dd><b>stuffit5::Exception</b>  if the archive cannot be opened<br><DT><b>Parameters:</b><DD><b>reader</b> -  a reader reference
<br></DL><P>
<A NAME="classify">
<A NAME ="DOC.181.2">
<DT><TT><b> exported  virtual  void  classify()</b></TT>
<DD>Determines archive format (<i>classifies</i> the archive). The
archive must be open with <code>open()</code> first.

<p>Classification does not rely (or, in fact, use in any way) file name
extension, file type or creator information. Instead, it relies on patterns
within compressed and encoded files that are specific to each format, such as
header structures and checksums in compressed archives, or limited character
sets in encoded files.

<p>By default, classification begins at the current archive position which can
be obtained by calling <code>archiveInfo().position()</code>, or controlled by
calling <code>archiveInfo().position(uint32_t)</code>. After an archive is open,
its initial position is 0.

<p>Archive format information is implicitly used by <code>scan()</code> and
<code>decode()</code>. To obtain archive format information for other purposes,
use <code>archiveInfo().format()</code> after <code>classify()</code>.

<p>Classification uses only a finite area of the archive immediately following
its current position to determine the format. The size of this classification
area can be obtained by calling <code>classifierSpan()</code>, or controlled
by calling <code>classifierSpan(size_t)</code>. The default size is chosen to exceed
the size of the majority of self-extracting code segments commonly used in
archive formats such as Zip, and may change between engine versions; if this
size is important, it should be set explicitly. If you want to find any
supported archive format, no matter how far into the archive, you can use
<code>classifierSpan(size_t)</code> to set the size of the classification area to
the size of the remaining portion of the file.


<dl><dt><b>Throws:</b><dd><b>stuffit5::Exception</b>  if the archive cannot be classified<br><DT><b>Parameters:</b><DD><b>reader</b> -  a reader reference
<br></DL><P>
<A NAME="scan">
<A NAME ="DOC.181.3">
<DT><TT><b> exported  virtual  void  scan()</b></TT>
<DD>Scans the archive.

<p>The archive must be open with <code>open()</code>, but does
not have to be classified with <code>classify()</code>. If the archive
has not been classified, <code>classify()</code> will be called
internally.

<p>Scan determines if the structure of the archive file is consistent
with its format, i.e, if it is complete and its overall structure is not
damaged. It also obtains summary information, such as the total number
of items in the archive (retrieved with a call to
<code>items()</code>), the number of items at the root level of the
archive, the name of the sigular
item at the root level (retrieved with <code>rootName()</code> but is
not available unless <code>hasMultupleRoots()</code> returns
<code>false</code>), and the total compressed and uncompressed size of
all items in the archive (retrieved with
<code>compressedSize()</code> and
<code>uncompressedSize()</code>, respectively.

<p>In some formats, such as Uuencode, determining sizes requires reading
the entire archive, so this operation may take noticeable time on large
archives.

<p>Throws an exception if the archive structure cannot be read or is invalid.


<dl><dt><b>Throws:</b><dd><b>stuffit5::Exception</b>  if the archive cannot be scanned<br></DL><P>
<A NAME="decode">
<A NAME ="DOC.181.4">
<DT><TT><b> exported  virtual  void  decode()</b></TT>
<DD>Decodes the archive and recreates all files contained in it at the
destination location. The archive must be open with <code>open()</code>,
but does not have to be classified with <code>classify()</code> or
scanned with <code>scan()</code>. If the archive has not been classified
or scanned, these operations will be executed internally before
decoding. Therefore, decoding may be requested immediately after a
successful <code>open()</code> if you do not need to know what archive
format you are dealing with, or any information about the archive that
is determined during the scan phase; this call effectively combines
classification, scan, and decoding, or scan and decoding, or simply
executes decoding when both classification and scan have been previously
completed.

<p>This call advances the archive position to the first byte past the
end of the decoded portion, except when this call returns
<code>false</code> due to an error, when the position may be advanced or
remain the same. This allows you to immediately proceed with a call to
<code>classify()</code> or <code>scan()</code> or <code>decode()</code>
to process any other archives that may follow the one that has just been
decoded, within the same physical file. This is a common situation with
concatenated encoded files, such as multipart uuencoded files combined
together in a single file, or within a mailbox file. This also allows
you to process disk image, backup and similar files of unknown structure
that combine multiple archives, but do not provide tools for easy
extraction of individual pieces.

<p>Throws an exception if the archive cannot be decoded.


<dl><dt><b>Throws:</b><dd><b>stuffit5::Exception</b>  if the archive cannot be decoded<br></DL><P>
<A NAME="close">
<A NAME ="DOC.181.5">
<DT><TT><b> exported  virtual  void  close()</b></TT>
<DD>Closes the currently open archive
<dl><dt><b>Throws:</b><dd><b>stuffit5::Exception</b>  if the archive cannot be closed<br></DL><P>
<A NAME="canClassify">
<A NAME ="DOC.181.6">
<DT><TT><b> exported  virtual  bool  canClassify(<!2><a href="#DOC.100">stuffit5::Format::type</a>  format) const </b></TT>
<DD>Returns <code>true</code> when the reader is capable of classifying
the format described by the <code>format</code> parameter
<dl><DT><b>Parameters:</b><DD><b>format</b> -  the format<br></DL><P>
<A NAME="canDecode">
<A NAME ="DOC.181.7">
<DT><TT><b> exported  virtual  bool  canDecode(<!2><a href="#DOC.100">stuffit5::Format::type</a>  format) const </b></TT>
<DD>Returns <code>true</code> when the reader is capable of decoding
the format described by the <code>format</code> parameter
<dl><DT><b>Parameters:</b><DD><b>format</b> -  the format<br></DL><P>
<A NAME="useMacDrive">
<A NAME ="DOC.181.8">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;bool&gt;   useMacDrive</b></TT>
<DD>MacDrive volume support option. The accessor returns <code>true</code> if the MacDrive volume support option is enabled.
MacDrive volume support allows readers to expand files into Macintosh HFS and
HFS+ volumes, preserving all Macintosh file information and resource fork
contents. This option is disabled by default.

<p>The mutator assigns the MacDrive volume support option that
applies to all subsequent archives, or until it is reassigned.
<dl></DL><P>
<A NAME="hasTextType">
<A NAME ="DOC.181.9">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;bool&gt;   hasTextType</b></TT>
<DD><code>true</code> when the reader supports text types. Depends on the
format being processed.
<dl></DL><P>
<A NAME="textType">
<A NAME ="DOC.181.18">
<DT><TT><b> <!1><a href="un.opt_property.html">un::opt_property</a>  &lt;<!2><a href="#DOC.244">stuffit5::TextType::type</a> &gt;   textType</b></TT>
<DD>Text type generated by the reader
<dl></DL><P>
<A NAME="hasTextConversion">
<A NAME ="DOC.181.10">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;bool&gt;   hasTextConversion</b></TT>
<DD><code>true</code> when reader supports text conversion. Depends on the
format being processed.
<dl></DL><P>
<A NAME="textConversion">
<A NAME ="DOC.181.19">
<DT><TT><b> <!1><a href="un.opt_property.html">un::opt_property</a>  &lt;<!2><a href="#DOC.236">stuffit5::TextConversion::type</a> &gt;   textConversion</b></TT>
<DD>Text conversion option
<dl></DL><P>
<A NAME="macBinaryOutput">
<A NAME ="DOC.181.20">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;<!2><a href="#DOC.174">stuffit5::MacBinaryOutput::type</a> &gt;   macBinaryOutput</b></TT>
<DD>MacBinary output option
<dl></DL><P>
<A NAME="destinationFolder">
<A NAME ="DOC.181.11">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;std::string&gt;   destinationFolder</b></TT>
<DD>The destination folder: a location where the reader creates output
files that it extracts from the archive. The default destination folder is
the folder where the archive is located.
<dl></DL><P>
<A NAME="classifierSpan">
<A NAME ="DOC.181.12">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;size_t&gt;   classifierSpan</b></TT>
<DD>Classifier span. Determines how far the reader looks into the archive
when trying to classify it. Unless a different span was set with
<code>classifierSpan(size_t)</code> this function returns the default
value of the classifier span.

<p>When doing archive classification, each reader starts at the current
archive position and uses the number of bytes equal to the value of the
classifier span property. This helps to achieve the right balance of
classification time and reliability.

<p>For example, some self-extracting archives may contain code segments
that are larger than the default classifier span. Unless the span value
is increased and is larger than the size of the segment of code, the
reader is not able to classify such files correctly. The span value can
be as large as the whole input file. While this helps to classify
archives that begin very far into the file, large spans lead to longer
delays and increase the probability of incorrect classification due to a
false match with one of the byte patterns inside the file.

<p>In identification of self-extracting archives is not an issue, classifier
span may be kept in the 1 KB to 8 KB range to allow for data between
concatenated archives or encoded files (such as email or news article
headers). When self-extracting archives need to be classified as well
good values for classifier span are between 32 KB and 128 KB, depending
on the maximum size of the self-extracting code likely to be encountered.

<p>To minimize the probability of incorrect identification, classifier
span must be kept as low as is acceptable. However, it should not be set
to values significantly lower then about 512 bytes, because low values
exclude the possibility of identification of one or more formats.
<dl></DL><P>
<A NAME="encryptionPassword">
<A NAME ="DOC.181.13">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="algorithm.Password.html">algorithm::Password</a> &gt;   encryptionPassword</b></TT>
<DD>The password used for file decryption in formats that support encrypted archives
(PrivateFile and StuffIt5). The maximum password length is 64 KB, 65536 characters.
The password is text usually entered by the user.  This function copies the password
for use in the writer. All writers that support encryption take care of transforming
the variable-size password to the (normally) fixed-size key.

<p>Every reader that has a password and a key erases them in the destructor.
However, for additional security, the password and the key can be erased
as soon as the archive is completely created (at the time of the
<code>ArchiveDecodeEnd</code> event callback).
<dl></DL><P>
<A NAME="encryptionKey">
<A NAME ="DOC.181.14">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="algorithm.Key.html">algorithm::Key</a> &gt;   encryptionKey</b></TT>
<DD>The key used for file decryption in formats that support encrypted archives
(PrivateFile and StuffIt5). The key can be set independently of the password
and overrides the key that has been or would have been generated internally
from the password. Every reader that has a key erases it in the destructor.
However, for additional security, the key can be erased as soon as the archive
is completely created (at the time of the <code>ArchiveDecodeEnd</code>
event callback).
<dl></DL><P>
<A NAME="newFileName">
<A NAME ="DOC.181.15">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;std::string&gt;   newFileName</b></TT>
<DD>The name of an unnamed file. The accessor returns the name of the
output file created by the reader when the file stored in the archive
has no name associated with it. This situation is handled through the
<code>FileNewName</code> event callback that preceeds the
<code>FileDecodeBegin</code> event callback. The accessor returns the
proposed generic file name (not a path name). The mutator assigns the
name of an unnamed file (not a path name).
<dl></DL><P>
<A NAME="archiveInfo">
<A NAME ="DOC.181.21">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="stuffit5.ArchiveInfo.html">stuffit5::ArchiveInfo</a> &gt;   archiveInfo</b></TT>
<DD>Archive information class
<dl></DL><P>
<A NAME="fileInfo">
<A NAME ="DOC.181.22">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="stuffit5.FileInfo.html">stuffit5::FileInfo</a> &gt;   fileInfo</b></TT>
<DD>File information class
<dl></DL><P>
<A NAME="folderInfo">
<A NAME ="DOC.181.23">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;<!1><a href="stuffit5.FolderInfo.html">stuffit5::FolderInfo</a> &gt;   folderInfo</b></TT>
<DD>Folder information class
<dl></DL><P>
<A NAME="userData">
<A NAME ="DOC.181.24">
<DT><TT><b> <!1><a href="un.property.html">un::property</a>  &lt;void*&gt;   userData</b></TT>
<DD>An arbitrary data pointer is carried to link instances of this class to
external per-instance data
<dl></DL><P>
<A NAME="isOpen">
<A NAME ="DOC.181.25">
<DT><TT><b> bool  isOpen</b></TT>
<DD>True if an archive is open
<dl></DL><P>
<A NAME="hasFormat">
<A NAME ="DOC.181.26">
<DT><TT><b> bool  hasFormat</b></TT>
<DD>True if archive format is known
<dl></DL><P>
<A NAME="scanned">
<A NAME ="DOC.181.27">
<DT><TT><b> bool  scanned</b></TT>
<DD>True if archive scan is complete
<dl></DL><P></DL>
<hr>
 <DL><DT><b>This class has no subclasses.</b></DL>
<dl><DT><b>Author:</b><DD>serge@aladdinsys.com

<DT><b>Version:</b><DD>$Revision: 1.12.2.1 $, $Date: 2001/07/05 23:32:33 $
</DL><P>
<hr>
<p><i>Generated by <a href="http://www.zib.de/Visual/software/doc++/index.html">doc++</a></i>

</body></html>
