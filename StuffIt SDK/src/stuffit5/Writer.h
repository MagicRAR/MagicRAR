// $Id: Writer.h,v 1.8.2.1 2001/07/05 23:32:33 serge Exp $
//
// Copyright (c)1996-2001 Aladdin Systems, Inc. All Rights Reserved.
// 245 Westridge Drive, Watsonville, CA 95076, USA
// http://www.aladdinsys.com/
// 1-831-761-6200
//
// This source code and specific concepts contained herein are confidential
// information and property of Aladdin Systems. Distribution is prohibited
// without written permission of Aladdin Systems.

#if !defined stuffit5_Writer_h_included
#define stuffit5_Writer_h_included

#include "stuffit5/bool.h"
#include "stuffit5/common.h"
#include "un/config.h"
#include "un/stdint.h"

#if compiler_msvc
    #pragma pack(push, 8)
#endif

#if defined __cplusplus

#include "un/warnings.h"
#include <list>
#include <string>
#include "algorithm/Password.h"
#include "algorithm/RandomizedKey.h"
#include "un/property.h"
#include "stuffit5/ArchiveInfo.h"
#include "stuffit5/bool.h"
#include "stuffit5/CompressionLevel.h"
#include "stuffit5/Error.h"
#include "stuffit5/FileInfo.h"
#include "stuffit5/FolderInfo.h"
#include "stuffit5/Format.h"
#include "stuffit5/TextType.h"
#include "stuffit5/event/WriterEventDispatcher.h"
namespace engine5 { class FormatWriter; }

/** StuffIt Engine writer.

@author serge@aladdinsys.com
@version $Revision: 1.8.2.1 $, $Date: 2001/07/05 23:32:33 $
*/

namespace stuffit5 {
    class Writer : public stuffit5::event::WriterEventDispatcher {
    public:
        /** Default constructor. */
        exported Writer();

        /** Destructor. */
        exported virtual ~Writer();

        /** Creates a new archive from all named files and folders.

        <p>Folders are acceptable only in formats that supports archive hierarchies,
        such as StuffIt and Zip. Encoded and sometimes compressed single-file formats
        do not allow folder inputs, only file input(s).

        <p>Archive name and format are writer properties and can be controlled with
        <code>archiveName(const std::string&)</code> and
        <code>format(stuffit5::Format)</code> functions.

        <p>If the format is not explicitly set, a StuffIt archive is generated.

        <p>There is always a default archive name generated if the name is not
        explicitly set. The exact form of the automatically generated name depends
        on the selected archive format.

        <p><code>names</code> is a list of strings that contain absolute or relative
        path names, one per each file or folder to be put into the archive.

        <p>This function throws an exception if archive creation has failed or was not
        completed.

        @param names list of files and folders to put into the archive
        @exception stuffit5::Exception if the archive cannot be created
        */
        exported virtual void create(const std::list<std::string>& names);

        /** Returns <code>true</code> when the writer is capable of creating
        the format described by the <code>format</code> parameter.
        @param format the archive format
        @return <code>true</code> if the writer can create the format
        */
        exported virtual bool canCreate(stuffit5::Format::type format) const;

        /** MacDrive volume support. The accessor returns <code>true</code> when
        MacDrive volume support option is enabled in the writer. MacDrive volume support
        allows writers to create archives from files in Macintosh HFS and HFS+ volumes,
        preserving all Macintosh file information and resource fork contents.
        This option is disabled by default.

        <p>The mutator assigns the MacDrive volume support option that applies to
        subsequent archives.
        */
        un::property<bool> useMacDrive;

        /** <code>true</code> if the text type option is supported by the writer.
        This depends on the format being created. The text type option controls
        the type of the text generated by the writer when it creates archives
        that are text files. The text type option is supported by BinHex and
        Uuencode writers.

        <p>This option is useful in a cross-platform setting where an archive is
        created on one platform, but read on another. Three common platforms,
        Windows, Macintosh and Unix, all use different line endings in text
        files.

        <p>The default setting of the text type option is to generate the <i>native</i>
        text type (i.e., the text type of the platform on which the archive is being
        created and the writer is executed.
        */
        un::property<bool> hasTextType;

        /** Text type generated by the writer. */
        un::property<stuffit5::TextType::type> textType;

        /** Compression level. The accessor returns the compression level used
        by the writer. This option is supported only by StuffIt, StuffIt5 and Zip writers.
        The exact meaning of the compression level setting is defined as part of
        the format. For example, Zip writer supports ten levels of compression,
        from 0 (no compression) and 1 (minimum compression, fastest speed) to 9
        (maximum compression, slowest speed). The mutator assigns the compression
        level that applies to subsequent files.
        */
        un::property<stuffit5::CompressionLevel::type> compressionLevel;

        /** The password used in file encryption. Applies to formats that support
        encrypted archives: PrivateFile and StuffIt5. The maximum password length
        Private File and StuffIt5 writers accept is 64 KB, 65536 characters.

        <p>The password is text usually entered by the user. All writers that support
        encryption take care of transforming the variable-size password to the
        (normally) fixed-size key.
        */
        un::property<algorithm::Password> encryptionPassword;

        /** The size (in bytes) of the key used in file encryption. The mutator can be
        used to set the size of the key in writers that support encryption with
        variable-size keys. PrivateFile writer supports three key sizes: 5, 8, and 16 bytes.
        StuffIt5 writer supports one key size (5 bytes) and ignores the key size
        assigned by this function.
        */
        un::property<size_t> encryptionKeySize;

        /** The randomized key (key and salt) used in file encryption.
        The key can be set independently of the password and overrides the
        key that has been or would have been generated internally from the
        password. This property should not be used in applications that interact
        with the user; use <code>encryptionPassword</code> instead.

        <p>(Salt is a random number concatenated with the key in order to randomize it.
        This increases security of some encryption algorithms when the same password
        (and consequently the same key) is repeatedly reused. New salt is generated
        as frequently as key changes are desired, usually once per file or block of data.
        The exact value of the salt is not kept secret, and is normally stored in the open,
        with the encrypted data.)
        */
        un::property<algorithm::RandomizedKey> encryptionKey;

        un::property<stuffit5::Error::type> errorCode;

        /** <code>true</code> when the archive size option is supported in the
        format being created.
        */
        un::property<bool> hasArchiveSize;

        /** The accessor returns the archive size.

        <p>The mutator assigns the archive size. The size has to be assigned
        before or at the time of the <code>ArchiveSize</code> event callback,
        before the archive is created. Supported only in StuffItSegment format.
        */
        un::property<uint32_t> archiveSize;

        /** <code>true</code> when the archive comment option is supported in the
        format being created.
        */
        un::property<bool> hasArchiveComment;

        /** The accessor returns the archive comment.

        <p>The mutator assigns the archive comment. The comment has to be assigned
        before or at the time of the <code>ArchiveEncodeBegin</code> event callback,
        before the archive is created. Supported only in StuffIt5 format.
        */
        un::property<std::string> archiveComment;

        /** Archive information class. */
        un::property<stuffit5::ArchiveInfo> archiveInfo;

        /** File information class. */
        un::property<stuffit5::FileInfo> fileInfo;

        /** Folder information class. */
        un::property<stuffit5::FolderInfo> folderInfo;

        /** An arbitrary data pointer is carried to link instances of this class to
        external per-instance data. */
        un::property<void*> userData;

    protected:
        engine5::FormatWriter* formatWriter;

        /** Validates input arguments and throws an exception if the format being creates
        does not accept directories or multiple inputs.
        @param names list of files and folders to put into the archive
        @exception stuffit5::exception::BadArgument if the inputs are invalid
        */
        void validateArguments(const std::list<std::string>& names) const;
    };
}

#endif // __cplusplus

#if !defined __cplusplus || defined stuffit5_implementation

/** Creates a new archive writer.

<p>Returns a writer reference that can be used to refer to the writer later.
Each writer must be deleted with a call to <code>stuffit5_Writer_delete()</code>.
Failure to delete writers leads to memory leaks.

@return a writer reference or <code>0</code>
*/
extern_c exported stuffit5_Writer stuffit5_Writer_new();

/** Deletes an archive writer.

<p>Use <code>stuffit5_Writer_delete()</code> to delete an existing writer by its
reference.

@param writer the writer reference
*/
extern_c exported void stuffit5_Writer_delete(stuffit5_Writer writer);

/** Creates a new archive.

<p>This function creates a new archive from all named files and folders.

<p>Folders are acceptable only in formats that supports archive hierarchies,
such as StuffIt and Zip. Encoded and sometimes compressed single-file formats do
not allow folder inputs, only file input(s).

<p>Archive name and format are writer properties and can be controlled with
<code>setWriterArchiveName()</code> and <code>setWriterArchiveFormat()</code>
functions.

<p>If the format is not explicitly set, a StuffIt archive is generated.

<p>There is always a default archive name generated if the name is not
explicitly set. The exact form of the automatically generated name depends on
the selected archive format.

<p><code>names</code> is an array of pointers to absolute or relative path
names, one per each file or folder to be put into the archive. The list is
terminated by an <code>engineNameListEnd</code> pointer value.

<p>This function returns <code>true</code> if the archive has been successfully
created, <code>false</code> if archive creation has failed or was not completed.
Use <code>stuffit5_Writer_getError()</code> to obtain error information.

@param names an array of pointers to path names, terminated by <code>engineNameListEnd</code>
@return true if the archive has been successfully opened
*/
extern_c exported bool stuffit5_Writer_create(const char** names, stuffit5_Writer writer);

/** Null file list entry. Indicates the end of the list of file and folder names
to be put into the archive. */
static const char* engineNameListEnd = (const char*)0;

/** Determines if a writer is capable of creating a format.

<p>Returns <code>true</code> when the writer is capable of creating the format
described by the <code>format</code> parameter, <code>false</code> otherwise.
The return value indicates that the writer this function applies to includes
code required to create the format.

@param format the archive format
@param writer the writer reference
@return <code>true</code> if the writer can create the format
*/
extern_c exported bool stuffit5_Writer_canCreate(stuffit5_Format_type format, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::useMacDrive()</code>. */
extern_c bool stuffit5_Writer_getUseMacDrive(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::useMacDrive()</code>. */
extern_c void stuffit5_Writer_setUseMacDrive(bool b, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::textType()</code>. */
extern_c exported bool stuffit5_Writer_hasTextType(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::textType()</code>. */
extern_c exported stuffit5_TextType_type stuffit5_Writer_getTextType(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::textType()</code>. */
extern_c exported void stuffit5_Writer_setTextType(stuffit5_TextType_type textType, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::compressionLevel()</code>. */
extern_c exported stuffit5_CompressionLevel_type stuffit5_Writer_getCompressionLevel(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::compressionLevel()</code>. */
extern_c exported void stuffit5_Writer_setCompressionLevel(stuffit5_CompressionLevel_type compressionLevel, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::password()</code>. */
extern_c exported bool stuffit5_Writer_setPassword(const char* password, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::keySize()</code>. */
extern_c exported size_t stuffit5_Writer_getKeySize(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::keySize()</code>. */
extern_c exported bool stuffit5_Writer_setKeySize(size_t keySize, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::key()</code>. */
extern_c exported bool stuffit5_Writer_setKey(const char* key, size_t keySize, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::archiveSize()</code>. */
extern_c exported bool stuffit5_Writer_hasArchiveSize(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::archiveSize()</code>. */
extern_c exported uint32_t stuffit5_Writer_getArchiveSize(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::archiveSize()</code>. */
extern_c exported void stuffit5_Writer_setArchiveSize(uint32_t archiveSize, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::archiveComment()</code>. */
extern_c exported bool stuffit5_Writer_hasArchiveComment(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::archiveComment()</code>. */
extern_c exported const char* stuffit5_Writer_getArchiveComment(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::archiveComment()</code>. */
extern_c exported void stuffit5_Writer_setArchiveComment(const char* archiveComment, stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::userData()</code>. */
extern_c exported void* stuffit5_Writer_getUserData(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::userData()</code>. */
extern_c exported void stuffit5_Writer_setUserData(void* p, stuffit5_Writer writer);

/** Returns the last error code set by the writer. Use this function to get error
values of type <code>stuffit5::Error::type</code>:

<ul><li>when <code>stuffit5_Writer_create()</code> function returns <code>false</code>,
indicating an error condition, and

<li>during the <code>Error</code> event callback to obtain the non-fatal error
code.</ul>

@param writer writer pointer
@return the error code
*/
extern_c exported stuffit5_Error_type stuffit5_Writer_getError(stuffit5_Writer writer);

/** C interface to <code>stuffit5::Writer::archiveInfo()</code>. */
extern_c exported stuffit5_ArchiveInfo stuffit5_Writer_archiveInfo(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::fileInfo()</code>. */
extern_c exported stuffit5_FileInfo stuffit5_Writer_fileInfo(stuffit5_Writer writer);
/** C interface to <code>stuffit5::Writer::folderInfo()</code>. */
extern_c exported stuffit5_FolderInfo stuffit5_Writer_folderInfo(stuffit5_Writer writer);

#endif // __cplusplus

#if compiler_msvc
    #pragma pack(pop)
#endif

#endif

